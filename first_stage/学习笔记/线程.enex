<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20201116T174615Z" application="Evernote/Windows" version="6.x">
<note><title>线程</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><span style="font-size: 14pt;">如何保证线程安全</span></div><div><br/></div><div>1.减少共享资源的存取冲突。2.设计适当的并行任务策略，保证任务与任务间不存在共享资源。3.确保一个客户的计算工作和数据访问只会被一个线程完成，而不是分给多个线程</div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">线程的基本状态以及状态间的关系</span></div><div><br/></div><div>新建（new）：新建了一个线程对象。</div><div>可运行（runnable）：线程对象创建后，其他线程调用了该对象的start（）方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权</div><div>运行（running）：可运行状态的线程获取了cpu时间片，执行程序代码。</div><div>阻塞（blocked）：线程因为某种原因放弃了cpu使用权，暂时停止运行，直到线程进入可运行状态，才有机会再次获得cpu时间片而转为运行状态，阻塞分三种状态：</div><div>1.等待阻塞：运行的线程执行调用wait（）方法，交出对象锁，JVM会把该线程收入等待队列中</div><div>2.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程使用，则JVM会把该线程放入等锁池中。</div><div>3.其他阻塞：运行的线程执行sleep（）或join（）方法，或者发出了I/O请求时，JVM会吧线程设置为阻塞状态，当sleep（）状态超时，join（）等待线程终止或者超时，或者IO处理完毕线程变回可运行</div><div>死亡（dead）：线程run（），main（）方法执行结束，或者因为异常退出了run（）方法，则该线程结束生命周期，死亡的线程不可再生。</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">解释一下什么是线程池</span></div><div><br/></div><div>面向对象编程中，创建和销毁对象是很费时间的，创建一个对象要获取内存资源或者其他更多资源。所以提高效率的一个手段就是减少对象的创建和销毁，“池化资源”由此产生，</div><div>事先创建若干可执行的线程放入一个池中，需要的时候从池中获取（而不是创建），不需要的时候放回池中（而不是销毁）。Java5+中的Executor接口定义一个线程执行工具，线程池接口ExecutorService提供静态工厂方法。可创建单线程、固定大小、无限大小的线程池等。</div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">举例说明同步和异步</span></div><div><br/></div><div>同步即阻塞式操作，非同步即非阻塞式操作。</div><div>如果系统中存在临界资源，例如正在写的数据被以后可能被另一个线程读到，或者正在读的数据可能被另一个线程写过了，那这些数据就必须同步存取。同步方法一旦开始调用，调用者必须等到方法返回后，才能继续后面的行为。异步方法一旦开始，方法调用就立即返回，调用者可以继续后面的操作。（比如煮面条的例子，刷锅，煮面是同步，煮的同时切菜是异步）</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">介绍一下线程同步和线程调度的相关方法</span></div><div><br/></div><div>wait（）：使一个线程处于等待（阻塞）状态，并且释放所持有的对象锁。</div><div>sleep（）：使一个正在运行的程序处于睡眠状态，是一个静态方法，调用此方法要处理interruptedException异常。</div><div>notify（）：唤醒一个处于等待状态的线程，当然在调用此方法时不能确切唤醒某个指定的等待线程，而是由JVM确定唤醒哪个线程，并且与线程优先级无关。</div><div>notifyAll（）：唤醒所有等待的线程，不过并不是把锁给所有线程，而是让他们竞争，只有获得锁的线程才能进入就绪状态。</div><div>还有Lock接口提供的锁机制，lock（）和unlock（）增强了灵活性和线程间的协调性，还有Condition对象用来进行线程间通信。java 5 还提供了信号量来限制对某个共享资源访问的线程数。</div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">一个线程进入一个对象的synchronized方法A之后，其他线程能否进入此对象的synchronize方法B？</span></div><div><br/></div><div>不能，第一个线程进入方法A的时候要取走对象锁，B只能进入此对象的非同步方法，如果要进入B，需要在等锁池等待（不是等待池）对象的锁</div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">简述一下线程的sleep（）方法和yield方法（）有什么区别</span></div><div><br/></div><div>sleep（）方法给其他线程运行机会时不会考虑线程的优先级，因此会给低优先级的线程运行机会。yield（）方法只会个同优先级或更高优先级的线程运行机会。</div><div>线程执行sleep（）方法后转入blocked状态， 执行yield（）方法后转入就绪状态。</div><div>sleep（）方法声明抛出interruptedException，而yield（）方法没有声明任何异常</div><div>sleep（）方法比yield（）方法（跟操作系统CPU调度相关）具有更好的可移植性。</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法？stop（）和suspend（）方法为何不推荐使用？</span></div><div><br/></div><div>两种方法：分别是继承Thread类和实现Runnable接口，实现Runnable接口更受人喜欢，因为不需要继承Thread类， 因为Java不支持多继承，如果该类已经继承了别的类，这里就只能用实现Runnable接口的方式实现一个线程。用synchronize修饰同步方法。反对使用stop（），是因为不安全，它会接触由线程获取的所有锁定，而且如果对象处于一种不连贯的状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend（）方法容易发生死锁。调用suspend（）的时候，目标线程会停下来，<span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。应该在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志挂起，则用wait（）进入等待；若标志恢复，则用notify（）重新启用线程。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">启用一个线程使用start（）还是run（）？</span></div><div><br/></div><div>使用start（），一个线程start后进入runnable状态（虚拟处理机准备就绪，表示它可以由JVM调度并执行，不过不会立即执行，当cpu分配时间给他时才开始执行run（）方法）</div><div>start（）是方法，它调用run（）方法，而run（）方法是必须重写的，run（）中包含的是线程主体。</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">sleep（）和wait（）的区别</span></div><div><br/></div><div>sleep是线程类的方法，导致此线程暂停执行指定时间，把执行机会让给其他线程，但是监控状态保持，到时会自动恢复，调用sleep不会释放对象锁。</div><div>wait是Object类的方法，对象调用wait方法会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法后本线程才进入对象锁定池准备获得对象锁进入运行状态。</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">说明一下在监视器（Monitor）的内部是怎么做到线程同步的，在程序又应该做到哪种级别的同步？</span></div><div><br/></div><div>监视器和锁在Java虚拟机中是一块使用的。监视器监听一块同步代码块，确定一次只有一个线程执行同步代码块。每个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码块</div><div><br/></div><div><br/></div><div><span style="font-size: 14pt;">分析同步方法和同步代码块的区别是什么？</span></div><div><br/></div><div>1.同步方法默认用this或者当前类class对象作为锁。2.同步代码块可以选择以什么来加锁，比同步方法更细颗粒度，我们可以选择只同步会发生同步问题的部分代码块而不是整个方法。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></en-note>]]></content><created>20200410T044219Z</created><updated>20200423T053834Z</updated><note-attributes><author>覃杨炀</author><source>desktop.win</source><source-url>https://www.nowcoder.com/tutorial/94/b40a485f92ff496b9fe332079fa5be66</source-url><source-application>yinxiang.win32</source-application></note-attributes></note></en-export>
