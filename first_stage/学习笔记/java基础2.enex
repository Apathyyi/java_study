<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20201113T073039Z" application="Evernote/Windows" version="6.x">
<note><title>java基础2</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><span style="font-size: 14pt;">常见的几种Map</span></div><div><br/></div><div>hashmap：存储键值对，键值可为空（但是只能一条记录）访问速度快，获取时顺序是随机的，线程不安全。&nbsp;&nbsp; &nbsp;</div><div>hashtable： <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">与 HashMap类似,它继承自Dictionary类，但是键值不能为空，线程安全，故效率低。</span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, STHeiti, &quot;Microsoft YaHei&quot;, 宋体; font-variant-caps: normal; font-variant-ligatures: normal;">LinkedHashMap：是hashmap的子类，存储的记录是有序的。先插入的先读出来。</span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 14pt;">请你介绍一下volatile</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">因为java虚拟机中，变量的值保存在主内存中，线程访问时获取副本，保存在自己的工作内存中，线程修改了这个值，会在某个时间把修改的值写会主内存，</span></div><div><span style="font-size: 10pt;">所以如果线程a读取了某个值并修改，但是并没立刻写回主内存，其他线程读到的还是原来的值，造成多线程同一个变量不一致。</span></div><div><span style="font-size: 10pt;">volatile关键字就是告诉虚拟机：</span></div><div><span style="font-size: 10pt;">1、每次访问变量，都是获取最新的值；</span></div><div><span style="font-size: 10pt;">1、变量修改了的值立马写回主内存</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 14pt;">IO中的几种writer和reader</span></div><div><span style="font-size: 10pt;">&nbsp;</span></div><div><span style="font-size: 10pt;">面向字符流 ：BufferWriter、FileWriter</span></div><div><span style="font-size: 10pt;">面向字节流：FileInputStream、ObjectInputStream</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 14pt;">哪个类是所有异常的父类</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;">Throwable，并不是Exception</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 14pt;">介绍一下堆和栈</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;">堆和栈都是java中存放数据的地方。</span></div><div><span style="font-size: 10pt;">栈：存取速度快，仅次于位于cpu中的寄存器，但是栈中的数据大小和生存周期必须是明确的，缺乏灵活性，且栈之间无法共享数据，但是栈内的多个值相等的变量可以指向同一个地址</span></div><div>堆：可以动态的分配大小，且不用事先告诉编译器生存周期，java的垃圾回收器会自动回收，但是因为需要动态分配内存，所以存取速度慢</div><div><br/></div><div>基础数据类型都存在栈中，int a =3，栈会为变量a创建一个内存空间，然后查找栈中有没有字面值为3的地址，如果没有的话开辟一个存放3字面值的地址，然后将a指向3的地址。如果有则直接指向。</div><div><br/></div><div>而包装数据（如String）全都存在堆中，java 用new（）语句显式的告诉编译器在运行时动态的创建。</div><div>String是个特殊的包装类，可以用new的方式创建，也可以直接String s = “abc”。前者是规范的创建过程，而后者的创建步骤：</div><div>（1）先定义一个名为str的String类的对象引用。</div><div>（2）在栈中查找有没有存放值为“abc”的地址，如果没有，则开辟一个地址存放“abc“，接着创建一个新的String类的对象s，并将s的字符串指向这个地址，而且在栈中这个地址旁边记下这个引用的对象s。如果已经有了值为”abc“的地址，则查找对象s，并返回s的地址</div><div>（3）将str指向对象s的地址</div><div>值得一提的是，一般String类型的变量都是直接存值的，只有像Sting str = ”abc“这样的创建方式，其字符串是保存一个指向存在栈中的数据的引用。</div><div><br/></div><div><span style="font-size: 10pt;">&nbsp;对于String str = new String（”abc“）：会创建2个对象</span></div><div><span style="font-size: 10pt;">不管常量池中有没有相同值的对象引用，都会在堆中创建一个String对象，这种String对象存的是字面值，然后再数据共享区中创建一个字符串常量的对象。</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="font-size: 10pt;"><br/></span></div></en-note>]]></content><created>20200312T072210Z</created><updated>20200918T073802Z</updated><note-attributes><author>覃杨炀</author><source>desktop.win</source><source-url>https://www.nowcoder.com/tutorial/94/ae05554a3ad84e42b6f9fc4d52859dc4</source-url><source-application>yinxiang.win32</source-application></note-attributes></note></en-export>
