<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20201116T174622Z" application="Evernote/Windows" version="6.x">
<note><title>线程2</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><span style="font-size: 14pt;">解释下Java多线程回调是什么意思</span></div><div><br/></div><div>所谓回调，就是客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便叫做回调方法</div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;">有几种线程池</font></div><div><br/></div><div>4种</div><div>newCachedTreadPool：可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</div><div><span style="color: rgb(51, 51, 51); font-family: system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span></div><div><span style="color: rgb(51, 51, 51); font-family: system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。</span></div><div><span style="color: rgb(51, 51, 51); font-family: system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。并且保证线程的执行顺序（FIFO，LIFO）</span></div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;">简要说明Java中cyclicbarrier和countdownlatch的区别是什么</font></div><div><br/></div><div>两者都能实现线程间的等待，不过侧重点不同：CountDownLatch一般用于某个线程A等待其他若干线程执行完之后它才执行，是可重用的</div><div>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行，是不可重用的。</div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;">说明一下你对AQS的理解</font></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="color: rgb(0, 0, 0); font-family: &quot;Microsoft Yahei&quot;, Avenir, &quot;Segoe UI&quot;, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;">AbstractQueuedSynchronizer，抽象队列同步器</font></span></div><div>AQS是Java并发包中的核心组件，内部实现的关键是：加锁的线程，state状态（0是没加锁），定义了内部类ConditionObject拥有两种线程独占模式和共享模式。</div><div>在LOCK包中的相关锁（常用的有ReentrantLock、ReadWriteLock）都是基于AQS来构建。底层原理详解见： <a href="https://new.qq.com/omn/20191010/20191010A0GD4E00">https://new.qq.com/omn/20191010/20191010A0GD4E00</a></div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">简述一下线程池的运行流程、使用参数及方法策略</font></div><div><br/></div><div>主要就是制定线程池核心线程数大小、最大线程数、存储队列、拒绝策略，空闲线程存活时长。当需要任务大于核心线程数的时候，就开始把任务往队列里存；存储队列满了以后开始增加线程池创建的线程数量，如果数量达到最大就开始执行拒绝策略，如直接丢弃任务，放弃最老的任务等。</div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;">介绍一下生产者消费者模式</font></div><div><br/></div><div>生产者把数据放入缓冲区，消费者从缓冲区拿数据。</div><div>降低耦合性。生产者和消费者不会产生依赖，如果互相调用对方的方法，那一方代码的修改会影响到另一方。</div><div>支持并发。由于函数调用是同步的，生产者调用消费者的某个方法，在生产者返回之前消费者必须等待，使用缓冲区后双方是独立的并发主体。</div><div>支持忙闲不均。如果生产者制造数据的速度很快，消费者来不及处理的数据就放缓冲区，等生产者速度慢下来消费者再慢慢处理。</div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">简述一下实现多线程同步的方法</font></div><div><br/></div><div>可以使用synchronized、lock、volatile、ThreadLocal来实现同步。</div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;">多线程中的i++线程安全吗？</font></div><div><br/></div><div>不安全，i++不是原子性操作。i++分为读数据，对i加一，再赋值给i++，执行期中任何一步都有可能被其他线程抢占资源。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></en-note>]]></content><created>20200416T084412Z</created><updated>20200417T071723Z</updated><note-attributes><author>覃杨炀</author><source>desktop.win</source><source-url>https://www.nowcoder.com/tutorial/94/317a5df7abfa4660b53c88edab48d34a</source-url><source-application>yinxiang.win32</source-application></note-attributes></note></en-export>
